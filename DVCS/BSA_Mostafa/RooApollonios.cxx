/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooApollonios.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 
#include <RooRealVar.h>
#include "RooRealConstant.h"

ClassImp(RooApollonios) 


 RooApollonios::RooApollonios(const char *name, const char *title, 
                              RooAbsReal& _m,
                              RooAbsReal& _m0,
                              RooAbsReal& _sigma,
                              RooAbsReal& _b):
   RooAbsPdf(name,title), 
   m("m","m",this,_m),
   m0("m0","m0",this,_m0),
   sigma("sigma","sigma",this,_sigma),
   b("b","b",this,_b),
   a1("a1","a1",this,(RooRealVar&)RooRealConstant::value(0.)),
   n1("n1","n1",this,(RooRealVar&)RooRealConstant::value(-1.)),
   a2("a2","a2",this,(RooRealVar&)RooRealConstant::value(0.)),
   n2("n2","n2",this,(RooRealVar&)RooRealConstant::value(-1.))
{} 


 RooApollonios::RooApollonios(const char *name, const char *title, 
                              RooAbsReal& _m,
                              RooAbsReal& _m0,
                              RooAbsReal& _sigma,
                              RooAbsReal& _b,
                              RooAbsReal& _a1,
                              RooAbsReal& _n1):
   RooAbsPdf(name,title), 
   m("m","m",this,_m),
   m0("m0","m0",this,_m0),
   sigma("sigma","sigma",this,_sigma),
   b("b","b",this,_b),
   a1("a1","a1",this,_a1),
   n1("n1","n1",this,_n1),
   a2("a2","a2",this,(RooRealVar&)RooRealConstant::value(0.)),
   n2("n2","n2",this,(RooRealVar&)RooRealConstant::value(-1.))
 {} 

 RooApollonios::RooApollonios(const char *name, const char *title, 
                              RooAbsReal& _m,
                              RooAbsReal& _m0,
                              RooAbsReal& _sigma,
                              RooAbsReal& _b,
                              RooAbsReal& _a1,
                              RooAbsReal& _n1,
                              RooAbsReal& _a2,
                              RooAbsReal& _n2):
   RooAbsPdf(name,title), 
   m("m","m",this,_m),
   m0("m0","m0",this,_m0),
   sigma("sigma","sigma",this,_sigma),
   b("b","b",this,_b),
   a1("a1","a1",this,_a1),
   n1("n1","n1",this,_n1),
   a2("a2","a2",this,_a2),
   n2("n2","n2",this,_n2)
 { 
 } 


 RooApollonios::RooApollonios(const RooApollonios& other, const char* name) :  
   RooAbsPdf(other,name), 
   m("m",this,other.m),
   m0("m0",this,other.m0),
   sigma("sigma",this,other.sigma),
   b("b",this,other.b),
   a1("a1",this,other.a1),
   n1("n1",this,other.n1),
   a2("a2",this,other.a2),
   n2("n2",this,other.n2)
 { 
 } 



 Double_t RooApollonios::evaluate() const{ 

   // add 1 or 2 CB tails
   bool lcb = (n1>0);
   bool rcb = (n2>0);

   Double_t aCB1=a1;
   Double_t aCB2=a2;
   Double_t nCB1=n1;
   Double_t nCB2=n2;
   

   // only right tail 
   if( lcb && !rcb && aCB1 < 0){
     lcb=false;
     rcb=true;
     aCB2=aCB1;
     nCB2=nCB1;
   }
   // switch if needed
   if( lcb && rcb && aCB1 < 0 && aCB2 > 0){
     Double_t at=aCB1;
     aCB1=aCB2;
     aCB2=at;
     Double_t nt=nCB1;
     nCB1=nCB2;
     nCB2=nt;
   }
   



   double absAlpha = fabs((double)aCB1);
   double absAlpha2 = fabs((double)aCB2);


   Double_t t = (m-m0)/sigma;
   double func = 0;
   if ( (t > -absAlpha || !lcb) && (t < absAlpha2 || !rcb) ) {
     func = exp(-b*sqrt(1+t*t));
   }else if (t < -absAlpha && lcb){   
     Double_t B = nCB1*sqrt(1+absAlpha*absAlpha)/(b*absAlpha) - absAlpha;
     Double_t A = exp(-b*sqrt(1+absAlpha*absAlpha)) *pow(B+absAlpha,nCB1);
     func = A*pow(B-t,-nCB1);
   }
   else if( t > absAlpha2 && rcb) {
     Double_t B = nCB2*sqrt(1+absAlpha2*absAlpha2)/(b*absAlpha2) - absAlpha2;
     Double_t A = exp(-b*sqrt(1+absAlpha2*absAlpha2)) *pow(B+absAlpha2,nCB2);
     func = A*pow(B+t,-nCB2);
   }
   return func;
 } 



